一、GIL是什么？
    GIL全称（Global Interpreter Lock）并不是Python的特性，他是在实现Python解释器(Cpython)时引入的一个概念。同一段代码可以通过Cpython，PyPy，Pstco等不同的Python执行环境来执行。其中Jpython就没有GIL。GIL并不是Python的特性，Python完全可以不依赖于GIL。

二、为什么有GIL
    由于物理上的限制，各CPU厂商在核心频率上的比赛已经被多核所取代，为了更有效的利用多核处理器的性能，就出现了多线程的编程方式，而随之带来的就是线程间数据一致性和状态同步的困难。
    为了利用多核，python也开始支持多线程。而解决多线程之间数据完整性和状态同步，即数据安全，最简单方法就是加锁。于是有了GIL这把超级大锁，而当越来越多的代码库开发者接受这种设定后，他们开始大量依赖这种特性（即默认python内部对象是thread-safe的，无需在实现时考虑额外的内存锁和同步操作）。

三、GIL的影响
    因为GIL，python只有一个GIL，运行python时，就要拿到这个锁才能执行，在遇到I/O操作时会释放这把锁。
    在python2中，如果是纯计算的程序，没有I/O操作，解释器会隔100次操作就释放这把锁，让别的线程有机会执行（这个次数可以通过sys.setcheckinterval调整），同一时间只会有一个获得GIL的线程在跑，其他线程都处于等待状态。
    1、如果是CPU密集型代码（循环、计算等），由于计算工作量多和大，计算很快就会达到100，然后触发GIL的释放与在竞争，多个线程来回切换损耗资源，所以在多线程遇到CPU密集型代码时，单线程会比多线程的快。
    2、如果是I/O密集型代码(文件处理、网络爬虫)，开启多线程实际上是并发(不是并行)，IO操作会惊醒IO等待，线程A等待时，自动切换到线程B，这样就提升了效率，比单线程快很多。

    而在python3.x中，GIL不使用ticks技术，改为使用计时器(执行时间达到阈值后，当前线程释放GIL)，这样对CPU密集型程序更加友好，但依然没有解决GIL导致的同一时间只能执行一个线程的问题，所以效率依然不尽如人意。
    多核多线程比单核多线程更差，原因是单核下多线程，每次释放GIL，唤醒那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入到待调度形状，这样会造成线程颠簸（thrashing），导致效率更低。
    "python下想要充分用多核CPU，就用多进程"，原因是什么？
    原因：每个进程有各自独立的GIL，互不干扰，这样就可以真正意义上的并行执行，(多线程并不是真正意义上的并行执行，只能算并发执行)，所以在python中，多进程的执行效率优于多线程(仅仅针对多核CPU而言)。

总结：
    python GIL其实是功能和性能之间权衡后的产物，它有存在的合理性，也有较难改变的客观因素。
    1、因为GIL的存在，只有IO密集型场景下的多线程会得到较好的性能，而在CPU密集型(计算密集型)或者高并发场景下，使用多进程效率会更高。
    2、GIL在较长的一段时间将会继续存在，但是会对其不断进行改进。
    3、GIL的目的是确保每个进程中只有一个线程执行，所以多个进程之间是不会相互影响的的，
        多进程确实可以用来削弱GIL的负面影响，但是对于IO密集型操作事物，多进程理论上也会比多线程快一点，
        但是因为多进程消耗的资源也比多线程多很多，所以如果只有少数的任务并发，用多进程没有问题，
        但是并发任务多的情况而且是IO密集型操作，用多线程就比多进程好得多，毕竟多线程占用的资源少，
        比多进程更加便于管理。多进程的管理比多线程要复杂而且不稳定。

