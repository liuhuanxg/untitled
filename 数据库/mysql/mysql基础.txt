一、MysQL基础架构
    客户端——>Service——>引擎
    其中在Service包含：
    连接器—>查询缓存—>分析器—>优化器—>执行器
    在查询缓存时，如果未查到就向下走到分析器，如果查询到之后，就返回结果。
    ① 连接器是什么？
        答：要进行查询时，第一步就是去连接数据库，这时就是连接器进行对接。分析器进行词法和语法分析，优化器执行计划生成，索引选择，执行器操作引擎，返回结果。
        负责Service跟客户端建立连接、获取权限、维持和管理连接。
        链接的时候会经过TCP握手，然后身份验证，然后我们输入用户名和密码就好了。
        验证之后，我们就连上了这个MySQL服务，但是这个时候我们处于空闲状态。

    ② 怎么查看空闲链接列表？
        答：show processlist，显示为Sleep的这一行，就表示现在系统里面有一个空闲；链接。
        需要注意：如果客户端太久没响应，连接器就会断开，这个参数是wait_timeout控制的，默认时间为8小时。

    ③ 除了重新链接之后，还有别的方式吗？
        答：使用长连接。但是有一个缺点，使用长连接之后，内存会飚得很快，因为MySQL在执行过程临时使用的内存是管理在链接对象里面的。只有在链接断开时候才能得到释放，那如果一直使用长链接，就会导致OOM(Out Of Memory)，会导致MySQL重启，在JVM里面就会导致频繁的Full GC。

    ④ 怎么解决这种问题？
        答：定期断开长链接，使用一段时间后，或者程序里面判断执行过一个占用内存比较大的查询后就断开链接，需要的时候重连就好了。

    ⑤ 还有其他的方法吗？
        答：执行完较大的查询后，可以执行mysql_reset_connetion可以重新初识化连接资源。这个过程不需要重新连接，但是会初始化链接状态。

    ⑥ 了解MySQL的查询缓存吗？
        答：MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。
        同一条MySQL语句执行两次，第一次和后面的时间是不一样的，后者明显会比第一次快，这就是因为缓存的存在。
        他跟Redis一样，只要是你之前执行过的语句，都会在内存里面用key-value形式存储。
        查询的时候就会拿着语句先去缓存中查询，如果能够命中就返回缓存的value，如果不命中就执行后面的阶段。

    ⑦ 缓存弊大于利指的是什么？
        答：缓存的失效很容易，只要对表有任何的更新，这个表和所有查询缓存就会被全部清空，就会出现缓存还没使用，就直接被清空了，或者积累了很多缓存准备用的时候，但是一个更新打回原形。
        这就会导致查询的命中率低的可怕，只有那种只查询不更新的表适用于缓存，但是这样的表很少存在，一般是配置表之类的。

    ⑧ 查询时候不想使用缓存一般怎么操作？或者想用缓存又怎么操作？
        可以显示调用，把query_cache_type设置成为DEMAND，这样SQL默认不适用缓存，想用缓存就用SQL_CACHE。
        一般在sql前面使用SQL_NO_CACHE就可以知道真正的查询时间了。
        如：select SQL_NO_CACHE * from B;
        缓存在8.0之后就取消了。

    ⑨ 缓存查询完了应该做什么？
        在缓存没有命中的情况下，就开始执行语句了，写的语句有没有语法错误，是接下来MySQL比较关心的点。
        首先做词法分析，分析语句中的单词、空格，MySQL需要识别每个字符串所代表的的是什么，是关键字，还是表名，还是列名等等。
        然后开始语法分析，根据词法分析的结果，语法分析会判断sql的对错，错了会提醒，并提示哪里错了。
        分析没错之后就进入下一步，优化器

    ⑩ 主要优化什么？
        因为建立表之后会建立很多索引，优化有一步就是要确认使用哪个索引，比如使用主键索引，联合索引还是什么索引更好。
        还有对执行顺序进行优化，条件那么多，先查哪个表，还是先关联，会出现很多方案，最后由优化器决定使用哪种方案。
        最后就是执行，执行交给执行器去做。
        第一步可能进行权限判断，执行的时候就一行行判断是否满足条件，有索引的执行起来可能就好点，一行行的判断就像是接口都提前在引擎中定义好了，所以比较快。
        数据库的慢日志有个rows_examined字段，扫描多少行可以看到，还有explain也可以看到执行计划，我们扫描了多少行。
