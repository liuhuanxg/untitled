八、创建索引
    1、索引是为了提升查询速度，会降低添加数据、更新数据、删除数据的速度。
    2、经常用于where查询条件的字段添加索引  如：id。
    3、字段重复数据较大的数据不适合添加索引，如：性别，保证数据的唯一性，唯一性越高查询速度越快。
    4、数量较少的表，不适合添加索引。
    索引介绍
		用处：  几乎所有的索引都是添加到字段中的
		作用：  使用索引，是为了加快查询速度，提高查询效率，约束数据的有效性
		原理：  系统根据某种算法或者未来添加的数据，单独建立一个文件，实现快速匹配查找
	索引的优点
		通过唯一索引可以创建出每一行数据的唯一性
		可大大提高数据库的检索速度，这是最主要的原因
		加强表与表之间的联系，实现多表查询
		在分组和排序中，同样可以少耗费很多时间
		可以提高表的性能
	索引的分类
		主键索引
			作用：  确定数据表中一条特定数据记录的位置
			关键字：  primary  key
			创建：  一般创建在建表时候  id  int  not  null  auto_increment  primary  key
			注意：  主键不能为空，一个表中只能有一个主键索引
		外键索引
			概念：  外面的键，不是在自己的表中，如果一张表中的一个字段（非主键）指向另一张表中的主键，那么可以称该字段为外键
			作用：  用来在多表查询的时候方便联系两表数据
			关键字：  foreign  key
			使用：  foreign  key（外键名）  references  主表（主键）
			约束
				对子表：  在对子表进行增和改的时候，如果外键对应在父表中找不到，那么就会失败
				对父表：  在对父表进行删和改的时候，如果在主表中已有数据被引用，那么也将失败
			外键的形成条件
				要求表类型必须是innodb
				如果不是innodb，那么及时创表成功，也没有了约束的效果
				外键的数据类型必须与主键的数据类型一致
				在一张表中外键名不能重复
				如果数据存在，那么必须保证外键中的数据和附表中的主键数据一致
		唯一索引
			作用：  唯一索引是为了避免出现重复的值，他的存在不是为了提高访问速度，而是避免出现重复数据
			关键字：  unique
			使用：  一般在创建列的时候使用   name  char（30）  not  null  default  ‘DB’  unique
			注意：  只有确认某一列不能出现重复的值得时候才能使用
		普通索引
			概念：  普通索引依附在某一列上，提高查询速度
			关键字：  index
			使用：  create  index  索引名  on  表名（列名）
		索引的操作
			查看索引：  show  index   from  表名
			删除索引：  drop  index  索引名  on  表名
	索引的缺点
		运行速度：  添加索引会延缓插入数据和修改数据的速度
		耗费空间：  索引本身产生的文件就有可能比数据的文件还要大
		消耗时间：  创建索引和维护索引要耗费时间，这种时间是根据数据量的增加而增加
    建立外键：
    create table score(id int not null auto_incriment
    primary key,python int not null default 80,linux int not
    null default 80,mysql int not null default 80,pid int
    not null default 1,foreign key(pid) references student(id));


     索引例句：
     select student.name,score.linux,score.python,score.mysql
     from student,score where score.pid=student.id;

     select student.name,score.python,score.linux,score.mysql
     from student join score on student.id=score.pid;


    (1)使用alter table 语句创建索引
        普通索引：
        alter table TABLE_NAME ADD INDEX INDEX_NAME(COLUMN_LIST);
        唯一索引：
        alter table TABLE_NAME ADD unique (COLUMN_LIST);
        主键索引：
        alter table table_name add primary key (COLUMN_LIST)；
    (2)使用create index语句对表增加索引
        create index index_name on table_name(username(length));
        如果是char或varchar类型，length可以小于字段实际长度;如果是BLOB和TEXT类型，必定要指定length
        create只能创建两种索引：普通索引和唯一索引
.        create unique index index_name on table_name (columb_list);
        不能使用create index创建primary key索引
    (3)删除索引
        删除索引可以使用alter table 或 drop index语句来实现，drop index可以在alter table内部作为一条语句处理
        格式:drop index index_name on table_name;
        alter table table_name drop index index_name;
        alter table table_name drop primary key;
        一个表只有一个primary key索引，如果没有primary key，有多个unique索引时，则MySQL将删除掉第一个unique索引。

(0)、索引的分类：
    SQL server索引类型有：唯一索引，主键索引，聚集索引，非聚集索引
    MySQL索引的类型有：唯一索引，主键(聚集索引)，非聚集索引，全文索引
    聚集索引：也叫聚簇索引
    定义：数据行的物理顺序与列值，(一般是主键的那一列)的逻辑顺序相同，一个表中只能拥有一个聚集索引。


(1)、索引有哪些数据结构？
    Hash和B+
(2)、为什么哈希表、完全平衡二叉树、B树、B+树都可以优化查询，为什么mysql独独喜欢B+树呢？
    ① 哈希表的特点是可以快速精确查询，但是不支持范围查询。如果做成了索引，速度也是很慢的，要全部扫描。
    ·哈希表适应哪些场景？
    等值查询的场景，就只有KV（Key，Value）的情况，例如Redis、Memcached等这些中间件。
    ·你说的是无序的Hash表，有没有有序的数据结构？
    有序数组，它在等值查询和范围查询的时候都很Nice。
    ·完全没有缺点吗？
    有序的适合静态数据，因为如果新增、删除、修改数据的时候就会改变他的结构。比如新增一个，那在新增的位置后面所有的节点都会后移，成本很高。可以用来存储比如2019年支付宝账单，2019年淘宝购物记录等等，都是不会变动的历史数据。
    ② 二叉树：
    二叉树是有序的，所以支持范围查询。但是它的时间复杂度是O(log(N))，为了保持这个时间复杂度，更新的时间复杂度也得是O(log(N))，那就要保持这个树是完全平衡二叉树了。
    ·平衡二叉树用来索引也不错？
        索引不只是在内存中进行存储，还是要落盘持久化的，如果数据多了之后，树会很高，查询的成本就会随着树高的增加而增加。一次千万级别的查询差不多要10秒钟。
    ·如果用B树呢？
        同样的元素，B树的表示要比完全平衡二叉树要“矮”，原因在于B树中的一个节点可以存储多个元素，B树其实已经是不错的数据结构，用来做索引效果也不错。
    ·为什么没有用B树，而用了B+树呢？
    B+树中的非叶子节点会冗余一份在叶子节点中，并且叶子结点之间用指针相连。
    ·那么B+树到底有什么优势呢？
    因为Hash不支持范围查询，二叉树的树高很高，只有B树和B+有的一比。
    B树的一个节点可以存储多个元素，相对于完全平衡二叉树的整体的树高降低了，磁盘IO效率提高了。
    而B+树是B树的升级版，只是把非叶子节点荣冗余一下，这么做的好处是为了提高范围查找的效率。提高的原因就是会有指针指向下一个节点的叶子节点。
    总结：Mysql选用B+树这种数据结构作为索引，可以提高查询索引时的磁盘IO效率，并且可以提高范围查询的效率，并且B+树的元素也是有序的。
(3)、一个B+树的节点到底有多少个元素最合适有了解吗？或者一个节点到底多大合适？
    B+树中一个节点为一页或者页的倍数最为合适。
    ·为什么？
    因为如果一个节点的大小小于1页，那么读取这个节点的时候其实也会读出一页，造成资源的浪费。如果一个节点的数据大于1页，比如1.2页，那么读取这个节点的时候会读出2页，也会造成资源的浪费。
    所以为了不造成浪费，最好把一个节点的控制在1页、2页、3页、4页等倍数页最为合适。
    ·提到了页的概念，能简单说一下吗？
    首先MySQL的基本存储结构是页（记录都存在页里边）。
    ①各个数据页可以组成一个双向链表。
    ②每个数据页中的记录又可以组成一个单向链表
    ③每个数据页都会为存储在它里边的记录生成一个页目录，在通过主键查找某条记录时可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。
    ④以其他列（非主键）作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。
    所以如果sql语句时select * from user where username="liuhuan"，这样没有进行优化的sql语句时，默认会这样做：
    ·定位到记录所在的页
    ·需要遍历双向链表，找到所在的页
    ·从所在的页内中查找相应的记录
    ·由于不是根据主键查询，只能遍历所在页的单链表
    在数据量很大的情况下这样查找会很慢，类似回表。

    回表是什么？
    回表大概就是有个主键为ID的索引，和一个普通name字段的索引，我们在普通字段上搜索：
    select * from table where name="liuhuan";
    执行流程是先查询到name索引上的"liuhuan",然后找到他的id是2，最后去主键索引，找到id为2对应的值。
    回到主键索引树搜索的过程，就是回表。不过也有方法避免回表，就是覆盖索引。
    什么是覆盖索引？
    比如在select *查询所有的，如果只查询到ID，这是name字段的索引上已经有了，就不需要回表了。覆盖索引可以减少树的搜索次数，提升性能，他也是我们在实际开发过程中经常用来优化查询效率的手段。很多联合索引的建立，就是为了支持索引覆盖，特定的业务能极大的提升效率。
(4)、索引的最左匹配原则知道吗？
    最左匹配原则：
    ·索引可以简单如一个列（a），也可以复杂如多个列（a,b,c,d），即联合索引。
    ·如果是联合索引，namekey也由多个列组成，同时索引只能用于查找key是否存在（相等），遇到范围查询(>,<,between,like左匹配)等就不能进一步匹配了，后续退化为线性查找。
    ·因此，列的排列顺序决定了可命中索引的列数。
    例子：
    ·如有索引(a,b,c,d)，查询条件a=a and b=2 and c>3 and d=4，则会在每个节点依次命中a、b、c，无法命中d(c已经是范围查询了，d肯定是排不了序了)

    总结：索引在数据库中是非常重要的知识点！
    基本的知识点包含：N叉树，跳表，LSM，同时创建出好的索引要顾及很多方面：
    ·最左前缀匹配原则。是非常重要、非常重要、非常重要的原则。MySQL会一直向右匹配直到遇到范围查询(>，<，between,like)就停止匹配。
    ·尽量选择区分度高的列作为索引，区分度的公式是COUNT(DISTINCT col)/COUNT(*)。表示字段不重复的比例，比率越大扫描的记录数就越少。
    ·索引列不能参与计算，尽量保持列"干净"。比如，FROM_UNIXTIME(create_time)='2016-06-06'就不能使用索引，因为B+树中存储的都是数据表中的字段值，但是进行检索时，需要把所有元素都应用函数才能比较。显然这样的代价比较大，所以要写成：create_time=UNIX_TIMESTAMP('2016-06-06')。
    ·尽可能的扩展索引，不要新建立索引。比如表中已经有了a的索引，现在要加（a，b）的索引，那么只需要修改原来的索引即可。
    ·单个多列组合索引和多个单列索引的检索查询效果不同，因为在执行SQL时，MySQL只能使用一个索引，会从多个单列索引中选择一个限制最为严格的索引（在MySQL5.0以后的版本中，有"合并索引"的策略，还是应该建立起来比较好的索引，而不应该依赖于"合并索引"这么一个策略）
    ·"合并索引"策略就是使用多个单列索引，然后将这些结果用"union或者and"来合并起来。
