八、创建索引
    1、索引是为了提升查询速度，会降低添加数据、更新数据、删除数据的速度。
    2、经常用于where查询条件的字段添加索引  如：id。
    3、字段重复数据较大的数据不适合添加索引，如：性别，保证数据的唯一性，唯一性越高查询速度越快。
    4、数量较少的表，不适合添加索引。
    (1)使用alter table 语句创建索引
        普通索引：
        alter table TABLE_NAME ADD INDEX INDEX_NAME(COLUMN_LIST);
        唯一索引：
        alter table TABLE_NAME ADD unique (COLUMN_LIST);
        主键索引：
        alter table table_name add primary key (COLUMN_LIST)；
    (2)使用create index语句对表增加索引
        create index index_name on table_name(username(length));
        如果是char或varchar类型，length可以小于字段实际长度;如果是BLOB和TEXT类型，必定要指定length
        create只能创建两种索引：普通索引和唯一索引
        create index index_name on table_name (column_list);
        create unique index index_name on table_name (columb_list);
        不能使用create index创建primary key索引
    (3)删除索引
        删除索引可以使用alter table 或 drop index语句来实现，drop index可以在alter table内部作为一条语句处理
        格式:drop index index_name on table_name;
        alter table table_name drop index index_name;
        alter table table_name drop primary key;
        一个表只有一个primary key索引，如果没有primary key，有多个unique索引时，则MySQL将删除掉第一个unique索引。

(1)、索引有哪些数据结构？
    Hash和B+
(2)、为什么哈希表、完全平衡二叉树、B树、B+树都可以优化查询，为什么mysql独独喜欢B+树呢？
    ① 哈希表的特点是可以快速精确查询，但是不支持范围查询。如果做成了索引，速度也是很慢的，要全部扫描。
    ·哈希表适应哪些场景？
    等值查询的场景，就只有KV（Key，Value）的情况，例如Redis、Memcached等这些中间件。
    ·你说的是无序的Hash表，有没有有序的数据结构？
    有序数组，它在等值查询和范围查询的时候都很Nice。
    ·完全没有缺点吗？
    有序的适合静态数据，因为如果新增、删除、修改数据的时候就会改变他的结构。比如新增一个，那在新增的位置后面所有的节点都会后移，成本很高。可以用来存储比如2019年支付宝账单，2019年淘宝购物记录等等，都是不会变动的历史数据。
    ② 二叉树：
    二叉树是有序的，所以支持范围查询。但是它的时间复杂度是O(log(N))，为了保持这个时间复杂度，更新的时间复杂度也得是O(log(N))，那就要保持这个树是完全平衡二叉树了。
    ·平衡二叉树用来索引也不错？
        索引不只是在内存中进行存储，还是要落盘持久化的，如果数据多了之后，树会很高，查询的成本就会随着树高的增加而增加。一次千万级别的查询差不多要10秒钟。
    ·如果用B树呢？
        同样的元素，B树的表示要比完全平衡二叉树要“矮”，原因在于B树中的一个节点可以存储多个元素，B树其实已经是不错的数据结构，用来做索引效果也不错。
    ·为什么没有用B树，而用了B+树呢？
    B+树中的非叶子节点会冗余一份在叶子节点中，并且叶子结点之间用指针相连。
    ·那么B+树到底有什么优势呢？
    因为Hash不支持范围查询，二叉树的树高很高，只有B树和B+有的一比。
    B树的一个节点可以存储多个元素，相对于完全平衡二叉树的整体的树高降低了，磁盘IO效率提高了。
    而B+树是B树的升级版，只是把非叶子节点荣冗余一下，这么做的好处是为了提高范围查找的效率。提高的原因就是会有指针指向下一个节点的叶子节点。
    总结：Mysql选用B+树这种数据结构作为索引，可以提高查询索引时的磁盘IO效率，并且可以提高范围查询的效率，并且B+树的元素也是有序的。
    ·一个B+树的节点到底有多少个元素最合适有了解吗？或者一个节点到底多大合适？
    B+树中一个节点为一页或者页的倍数最为合适。
    ·为什么？
    因为如果一个节点的大小小于1页，那么读取这个节点的时候其实也会读出一页，造成资源的浪费。如果一个节点的数据大于1页，比如1.2页，那么读取这个节点的时候会读出2页，也会造成资源的浪费。
    所以为了不造成浪费，最好把一个节点的控制在1页、2页、3页、4页等倍数页最为合适。
    ·提到了页的概念，能简单说一下吗？
    首先MySQL的基本存储结构是页（记录都存在页里边）。
    ①各个数据页可以组成一个双向链表。
    ②每个数据页中的记录又可以组成一个单向链表
    ③每个数据页都会为存储在它里边的记录生成一个页目录，在通过主键查找某条记录时可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。
    ④以其他列（非主键）作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。
    所以如果sql语句时select * from user where username="liuhuan"，这样没有进行优化的sql语句时，默认会这样做：
    ·定位到记录所在的页
    ·需要遍历双向链表，找到所在的页
    ·从所在的页内中查找相应的记录
    ·由于不是根据主键查询，只能遍历所在页的单链表
    在数据量很大的情况下这样查找会很慢，类似回表。

    回表是什么？
    回表大概就是有个主键为ID的索引，和一个普通name字段的索引，我们在普通字段上搜索：
    select * from table where name="liuhuan";
    执行流程是先查询到name索引上的"liuhuan",然后找到他的id是2，最后去主键索引，找到id为2对应的值。
    回到主键索引树搜索的过程，就是回表。不过也有方法避免回表，就是覆盖索引。
    什么是覆盖索引？
    比如在select *查询所有的，如果只查询到ID，这是name字段的索引上已经有了，就不需要回表了。覆盖索引可以减少树的搜索次数，提升性能，他也是我们在实际开发过程中经常用来优化查询效率的手段。很多联合索引的建立，就是为了支持索引覆盖，特定的业务能极大的提升效率。
    索引的最左匹配原则知道吗？
    最左匹配原则：
    ·索引可以简单如一个列（a），也可以复杂如多个列（a,b,c,d），即联合索引。
    ·如果是联合索引，namekey也由多个列组成，同时索引只能用于查找key是否存在（相等），遇到范围查询(>,<,between,like左匹配)等就不能进一步匹配了，后续退化为线性查找。
    ·因此，列的排列顺序决定了可命中索引的列数。
    例子：
    ·如有索引(a,b,c,d)，查询条件a=a and b=2 and c>3 and d=4，则会在每个节点依次命中a、b、c，无法命中d(c已经是范围查询了，d肯定是排不了序了)

    总结：索引在数据库中是非常重要的知识点！
    基本的知识点包含：N叉树，跳表，LSM，同时创建出好的索引要顾及很多方面：
    ·最左前缀匹配原则。是非常重要、非常重要、非常重要的原则。MySQL会一直向右匹配直到遇到范围查询(>，<，between,like)就停止匹配。
    ·尽量选择区分度高的列作为索引，区分度的公式是COUNT(DISTINCT col)/COUNT(*)。表示字段不重复的比例，比率越大扫描的记录数就越少。
    ·索引列不能参与计算，尽量保持列"干净"。比如，FROM_UNIXTIME(create_time)='2016-06-06'就不能使用索引，因为B+树中存储的都是数据表中的字段值，但是进行检索时，需要把所有元素都应用函数才能比较。显然这样的代价比较大，所以要写成：create_time=UNIX_TIMESTAMP('2016-06-06')。
    ·尽可能的扩展索引，不要新建立索引。比如表中已经有了a的索引，现在要加（a，b）的索引，那么只需要修改原来的索引即可。
    ·单个多列组合索引和多个单列索引的检索查询效果不同，因为在执行SQL时，MySQL只能使用一个索引，会从多个单列索引中选择一个限制最为严格的索引（在MySQL5.0以后的版本中，有"合并索引"的策略，还是应该建立起来比较好的索引，而不应该依赖于"合并索引"这么一个策略）
    ·"合并索引"策略就是使用多个单列索引，然后将这些结果用"union或者and"来合并起来。















