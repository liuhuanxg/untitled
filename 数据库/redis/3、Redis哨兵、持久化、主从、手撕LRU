1、Redis为什么那么快？
    在普通的数据库中，索引存储在内存中，具体的数据存储在硬盘中。
    但是在redis数据库中，数据直接存储在内存中，所以速度会快很多。
    Redis采用的是基于内存的单进程单线程模型的KV数据库，由C语言编写，官方提供的数据是可以达到10万+的QPS（每秒查询速度）
    ① 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存储在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)。
    ② 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的。
    ③ 采用单线程，避免了不必要的上下文切换和竞争条件。也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致性能消耗。
    ④ 使用多路I/O复用模型，非阻塞IO
    ⑤ 使用底层模型不同，他们之间底层实现方式及客户端之间通信的应用协议不一样，Redis直接自己构建VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

2、什么是上下文切换，为什么会导致线程不安全？
    比如一个人看书，在某个地方加了书签，但是这时有其他人过来动了一下书签，这个时候书签的内容就变了。就是因为一个人操作的时候，怎么样都可以，但是人多了换来换去的操作，书的内容就乱了。

3、Redis是单线程的，但是服务器是多核的，会不会很浪费？
    是的，是单线程的，但是可以通过在单机上开多个Redis实例进行操作。

4、既然提到了单机会有瓶颈，怎么解决这个瓶颈？
    用到集群的部署方式，也就是Redis cluster，并且是主从同步，读写分离，类似Mysql的主从复制，Redis cluster支撑N个Redis master node，每个master node都可以挂载多个salve node。
    这样整个Redis就可以进行横向扩展了，如果要支撑更大数据量的缓存，那就横向扩容更多的master节点，每个master节点就能存放更多的数据了。

5、他们之间怎么进行数据交互的？以及Redis是怎么进行持久化的?Redsi数据都在内存中，一断电或者重启不就有了吗？
    持久化是Redis高可用中比较重要的一个环节，因为Redis数据在内存的特性，持久化必须得有，持久化有两种方式。
    ① RDB：RDB持久化机制，是对Redis中的数据执行周期性的持久化。
    ② AOF：AOF机制对每条写入命令作为日志，以append-only的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像MySQL的binlog。
    两种方式都可以把Redis内存中的数据持久化到磁盘上，然后再将这些数据备份到别的地方去，RDB更适合做冷备，AOF更适合做热备。
    两种机制全部开启时候，Redis再重启的时候会默认使用AOF去重新构建数据，因为AOF的数据比RDB更完整。

6、这两种机制各自优缺点是什么？
    RDB优点：
        会生成多个数据文件，每个数据文件分别都代表某一时刻Redis里面的数据，这种方式更适合做冷备，完整的数据运维设置定时任务，定时任务同步到远端服务器，比如阿里的云服务，这样一旦线上挂了，想恢复多少分钟之前的数据，就去远端拷贝一份之前的数据。
        RDB对Redis的性能影响非常小，是因为在同步数据的时候他只是fork了一个子进程去做持久化的，而且他在数据恢复的时候速度比AOF来的快。
    RDB缺点：
        RDB都是快照文件，根据数据变化情况进行持久化，实时性不高。
        AOF则最多丢一秒的数据。
        RDB在生成数据快照的时候，如果文件很大，客户端可能会暂停几毫秒甚至几秒。容易造成大的问题。
    AOF优点：
        RDB定时生成快照，但是AOF是一秒一次去通过一个后台的线程fsync操作，那最多丢这一秒的数据。
        AOF在对日志文件进行操作的时候是以append-only的方式去写的，他只是追加的方式写数据，自然就少了很多磁盘寻址的开销，写入性能惊人，文件也不容易破损。
        AOF的日志是以一个可读的方式记录的，这样的特性就是误删除的紧急恢复。比如某人通过flushall清空了所有的数据，只要这个时候后台重写还没有发生，马上拷贝一份AOF日志文件，把最后一条flushall命令删除就完事。
    AOF缺点：
        一样的数据，AOF文件要比RDB大
        AOF开启后，Redis支持写的QPS会比RDB支持写的要低，每秒都要去异步刷新一次日志fsync，即使这样时性能还是很高，ElasticSearch也是这样的，异步刷新缓存区的数据去持久化。

7、两者怎么选择？
    单独用RDB会丢失很多数据，单独用AOF数据恢复没RDB来的快，真出事时候第一时间用RDB恢复，然后用AOF做数据补全。冷备热备一起上，才是互联网时代一个高健壮性系统的王道。

8、Redis还有其他保证集群高可用的方式吗？
    哨兵集群sentinal。
        哨兵必须用三个实例去保证自己的健壮性，哨兵+主从并不能保证数据不丢失，但是可以保证集群的高可用。
    为什么要三个实例呢？
        master宕机了，s1和s2两个哨兵只要有一个认为你宕机就切换了，并且会选举出一个哨兵去执行故障，但是这个时候也需要大多数哨兵都是运行的。
        三个实例时：M1所在的机器挂了，哨兵还有两个，这两个哨兵可以选举一个出来执行故障转移。
    哨兵组件的主要功能：
        ① 集群监控：负责监控Redis master和salve进程是否正常工作。
        ② 消息通知：如果某个Redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员。
        ③ 故障转移：如果master node挂掉了，会自动转移到slave node上
        ④ 配置中心：如果故障转移发生了，通知client客户端新的master地址。

9、主从同步数据之间是怎么同步的？
    为什么要用主从这样的架构模式？因为单机QPS是有上限的，而且Redis的特性就是必须支撑读高并发的，那一台机器又读又写，这个时候机器会顶不住这时可以选择master机器去写，数据同步给别的slave机器，这些机器都拿去读，分发掉大量的请求，而且扩容的时候还可以轻松实现水平扩容。
    怎么进行数据同步？
    启动一台slave时候，他会发送一个psync命令给msater，他会触发一个全量复制。master就会启动一个线程，生成RDB快照，还会把新的写请求都缓存在内存中，RDB文件生成后，master会将这个RDB发送给slave的，salve拿到之后做的第一件事就是写进本地磁盘，然后加载进内存，然后master会把内存里面缓存的新命名都发给slave。

10、数据传输的时候断网了或者服务器挂了怎么办？
    传输过程中有什么网路问题的，会自动重连，并且连接之后会把之前缺少的数据补上。
    RDB快照的数据生成的时候，缓存区也必须同时开始接受新请求，不然旧的数据过去了，你在同步期间的增量数据无法同步。

11、手写LRU代码
    Redis的过期策略：定期删除+惰性删除两种
    定期就是默认100ms就随机抽一些设置了过期时间的key，去检查是否过期，过期了就删了。

12、为啥不扫描全部设置了过期时间的key？
    假如Redis里面所有的Key都有过期时间，都扫描一遍耗时较长，而且线上基本上都是设置一定的过期时间。全扫描跟不带where条件不走索引全表扫描一样。

13、如果一直没随机到很多Key，里面不就存在大量的无效key了？
    惰性删除：等查询的时候才会检查有没有过期，过期了就删了，没过期就继续保留。

14、如果定期没删，也没查询，会怎样？
    此时就用到了内存淘汰机制：
    ① noeviction：返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）
    ② allkeys-lru：尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
    ③ volatile-lru：尝试回收最少使用的键LRU，但仅限于在过期集合的键，使得新添加的数据有空间存放。
    ④ allkeys-random：回收随机的键使得新添加的数据有空间存放。
    ⑤ volatile-random：回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
    ⑥ volatile-ttl：回收在过期集合的键，并且优先回收存活时间（TTL）较短的键，使得新添加的数据有存放空间。
    如果没有键满足回收的前提条件的话，策略volatile-lru，volatile-random以及volatile-ttl就合noeviction差不多。
