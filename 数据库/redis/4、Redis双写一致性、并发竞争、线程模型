一、Redis的特性，和分别使用的场景？
    String：最简单的类型，普通的set和get，做简单的kv缓存。但是在真实的开发环境中，很多人可能会把很多比较复杂的结构也同意转成String去存储使用，比如有的人喜欢把对象或者List转换为JSONString进行存储，拿出来再反序列。
    (1)String的实际应用场景：
        ① 缓存功能：String字符串是最常用的数据类型，不仅仅是Redis，各个语言都是最基本类型，因此，利用Redis作为缓存，配合其他数据库作为存储层，利用Redis支持高并发的特点，可以大大加快系统的读写速度，以及降低后端数据库的压力。
        ② 计数器：很多系统都会使用Redis作为系统的实时计数器，可以快速实现计数和查询功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其他存储介质中进行永久保存。
        ③ 共享用户session：用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存Cookie，但是可以利用Redis将用户的Session集中管理，在这种模式只需要保证Redis的高可用，每次用户Session的更新和获取都可以快速完成。大大提高效率。
    (2)Hash：
        类似Map的一种结构，一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他对象）给缓存在Redis中，然后每次读写缓存的时候，就可以操作Hash里的某个字段。
    (3)List：
        list是有序列表，可以通过List存储一些列表型的数据结构，类似粉丝列表，文章的评论列表等。
        比如可以通过lrange命令，读取某个闭区间内的元素，可以基于List实现分页查询，这个是很棒的功能，基于Redis实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页页走。
        比如可以搞简单的消息队列，从List头怼进去，从List屁股那里弄出来。
        List本身就是在开发过程中比较常用的数据结构。
        ① 消息队列：Redis的链表结构，可以轻松实现阻塞队列，可以使用左进右出的命令组成来完成队列的设计。比如：数据的生产者可以通过Lpush命令从左边插入数据，多个数据消费者，可以使用BRpop命令阻塞的抢列表尾部的数据。
        ② 文章列表或者数据分页展示的应用。
        比如，我们常用的博客网站的文章列表，当用户量越来越多时，而且每一个用户都有自己的文章列表，而且当文章列表多时，都需要分页展示，这时可以考虑使用Redis的列表，列表不但有序同事还支持按照范围内获取元素，可以完美解决分页查询功能，大大提高查询效率。
    (4)Set是无序集合，会自动去重
        直接基于Set将系统里需要去重的数据扔进去，自动就给去重了，如果你需要对一些数据进行快速的全局去重。也可以进行交集、并集、差集的操作。
    (5)Sorted Set
        Sorted set是排序的Set，去重但可以排序，写进去的时候给一个分数，自动根据分数排序。
        有序集合的使用场景与集合类似，但是set集合不是自动有序的，而Sorted set可以利用分数进行成员间的排序，而且是插入时就排好序。所以当你需要一个有序且不重复的集合列表时，就可以选择Sorted set数据结构作为选择方案。
        ① 排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。。
        ② 用Sorted Sets来做带权重的队列，比如普通消息的score为1，重要的消息score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。

二、如果多个系统同时操作（并发）Redis带来的数据问题？
    错误描述：系统A、B、C三个系统，分别取操作Redis的同一个Key，本来顺序是1,2,3是正常的，但是因为系统A网络突然抖动一下，B，C在他1前边操作了Redis，这个时候就会造成数据错误。
    就好比下单、支付、退款三个顺序变了，先退款，再下单、再支付，整个流程就会失败。

三、这种情况怎么解决？
    使用锁进行解决，某个时刻多个系统都去更新某个Key，可以基于Zookeeper实现分布式锁。每个系统通过Zookeeper获取分布式锁，确保同一时刻，只能有一个系统实例在操作某个key，别人都不允许读和写。
    要写入缓存的数据，都是从MySQL里查询出来的，都得写入MySQL中，写入MySQL中的时候必须保存一个时间戳，从MySQL查出来的时候，时间戳也能查出来。
    每次写之前，先判断一下当前这个Value的时间戳是否比缓存里的Value的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。

四、只要使用缓存，就可能涉及到缓存与数据库双存储双写，只要是双写，就会有数据一致性问题，那么是如何解决的？
    一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是如果系统不是严格要求“缓存+数据库”必须保持一致性的话，最好不要做这个方案，即：读请求和写请求串行化，串到一个内存队列里。
    串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多基本的机器去支撑线上的一个请求。
    把一系列的操作都放到队列里面，顺序肯定不会乱，但是并发高了，这队列很容易阻塞，反而会成为整个系统的弱点，瓶颈。

五、你了解最经典的KV、DB读写模式么？
    最经典的缓存+数据库读写的模式，就是Cache Aside Pattern
    ① 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
    ② 更新的时候，先更新数据库，然后再删除缓存。

六、为什么是删除缓存，而不是更新缓存？
    很多时候，在复杂的缓存场景，缓存不单单是数据库中直接取出来的值。
    比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值。
    另外更新缓存的代价有时候是很高的。是不是说每次修改完数据库的时候，都一定要将其对应的缓存更新一份？也许有的场景是这样，但是对于比较复杂的缓存数据计算的场景，就不是这样了。如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新，但是问题在于，这个缓存到底会不会被频繁访问到？
    举个例子：一个缓存涉及的表的字段，在一分钟内就修改了20次，或者是100次，那么缓存更新20次、100次，但是这个缓存在1分钟只被读取了1次，有大量的冷数据。
    实际上，如果只是删除缓存的话，那么在1分钟内，这个缓存不过就重新计算一次，开销大幅度降低，用到缓存才去算缓存。
    其实删除缓存，而不是更新缓存，就是一个Lazy计算的思想，不要每次都重新做复杂的运算，不管他会不会用到，而是让它到需要被使用的时候再重新计算。
    像Mybatis，Hibernate，都有懒加载思想，查询一个部门，部门带了一个员工的List，没有必要说每次查询部门，都里面的1000个员工的数据同时查出来，80%的情况，查这个部门，就只是要访问这个部门的信息就可以了。先查部门，同时要访问里面的员工，那么这个时候只要在访问里边员工的时候，才会去数据库里边查询1000个员工。

七、Redis和Memcached有啥，为啥用Redis作为你们的缓存中间件？
    Redis支持复杂的数据结构：
    Redis相比Memcached来说，拥有更多的数据结构，能支持更丰富的数据操作。如果需要缓存能够支持更复杂的结构和操作，Redis会是个不错的选择。
    Redis原生支持集群模式：
    在redis3.x版本中，便能支持Cluster模式，而Memcached没有原生的集群模式，需要依靠客户端来实现往集群分片写入数据。
    性能对比：
    由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100K以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行了优化，但是比起Remcached，还是略有逊色。

八、Redis的线程模型了解么？
    Redis内部使用文件事件处理器file event handler，这个文件事件处理器是单线程，所以Redis才叫单线程的模型，它采用IO多路复用机制同时监听多个Socket，根据Socket上的事件来选择对应的事件处理器进行处理。
    文件事件处理器结构包含4个部分：
        ·多个Socket
        ·IO多路复用程序
        ·文件事件分排气
        ·事件处理器（链接应答处理器，命令请求处理器，命令回复处理器）
    多个Socket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个Socket，会将Socket产生的事件放入队列中排队，事件分排气每次从队列中取出一个时间，把该交给对应的事件处理器进行处理。
